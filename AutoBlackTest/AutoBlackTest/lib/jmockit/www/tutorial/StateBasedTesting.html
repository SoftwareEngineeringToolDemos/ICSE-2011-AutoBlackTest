<!DOCTYPE html>
<!--
  ~ Copyright (c) 2006-2012 RogÃ©rio Liesenfeld
  ~ This file is subject to the terms of the MIT license (see LICENSE.txt).
  -->
<html>
<head>
   <title>The JMockit Tutorial - State-based testing</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <link rel="stylesheet" type="text/css" href="../prettify.css"/>
   <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"/>
   <script type="text/javascript" src="../highlight.pack.js"></script>
   <script type="text/javascript">hljs.initHighlightingOnLoad()</script>
</head>
<body>
<h2>
   State-based testing with JMockit
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="ReflectionUtilities.html"><img align="right" src="go-next.png" title="Next chapter"></a>
      <a href="BehaviorBasedTesting.html"><img align="right" src="go-previous.png" title="Previous chapter"></a>
   </div>
</h2>

<ol style="border: medium ridge; background-color: beige;">
   <li><a href="#mocks">Mock methods and mock classes</a></li>
   <li>
      <a href="#setUp">Setting up mocks for a test</a>
      <ol>
         <li><a href="#mockableMethods">Which kinds of methods can have mocks?</a></li>
         <li><a href="#inline">In-line mock classes</a></li>
      </ol>
   </li>
   <li><a href="#interfaces">Mocking interfaces</a></li>
   <li><a href="#constraints">Invocation count constraints</a></li>
   <li><a href="#initializers">Mocking and stubbing class initializers</a></li>
   <li><a href="#it">Accessing the mocked object: the "it" field</a></li>
   <li><a href="#reentrant">Reentrant mocks</a></li>
   <li>
      <a href="#reuse">Reusing mocks between tests</a>
      <ol>
         <li><a href="#beforeAfter">Using before/after methods</a></li>
         <li><a href="#reusableMocks">Reusable mock classes</a></li>
      </ol>
   </li>
</ol>

<p>
   In the JMockit toolkit, the <strong>Mockups API</strong> provides support for the creation of <em>state-based</em>
   tests and for the creation of <em>fake</em> implementations.
</p>
<div style="text-align: center;">
   <map name="figure1">
      <area shape="rect" coords="1,1,86,34" href="../javadoc/mockit/Mockit.html">
      <area shape="rect" coords="93,1,223,34" href="../javadoc/mockit/MockUp.html">
      <area shape="rect" coords="232,1,307,34" href="../javadoc/mockit/Mock.html">
      <area shape="rect" coords="315,1,430,34" href="../javadoc/mockit/MockClass.html">
      <area shape="rect" coords="439,1,574,34" href="../javadoc/mockit/Instantiation.html">
   </map>
   <img src="StateBasedAPI.png" usemap="#figure1">
</div>
<p>
   In <em>state-oriented mocking</em>, the focus is not on the interactions between a tested class and its dependencies,
   but on the data items received by and returned from those dependencies.
   Rather than writing a test from the perspective of the <em>tested</em> class, we write it from the perspective of the
   <em>used</em> classes, regardless of who uses them.
   Such tests extend regular state verification, which is typically performed through JUnit/TestNG assertions written at
   the end of a test method, with assertions on parameter values that get executed at the time a mocked
   method/constructor of a dependency is invoked by the tested class.
</p>
<p>
   As for fake implementations, they can be particularly useful in <em>integration</em> tests which depend on external
   entities or resources such as the network, the file system, etc.
   The <em>faking</em> of dependencies which access such external entities allows us to run the same integration
   test in two "modes":
   1) a "real" mode, where all code (tested unit <em>and</em> its dependencies) is exercised normally; and
   2) an "emulated" mode, where the "problematic" dependencies have their implementations replaced with fake ones, so
   that the test can succeed even with no network connection, no file system, or whatever external dependency it would
   need otherwise.
   The replacement of real implementations with fakes is completelly transparent to the code which uses those
   dependencies, and can be switched on and off for different test runs.
</p>
<p>
   For the remaining of this chapter, lets say we want to write tests for an application that uses the
   <a href="http://download.oracle.com/javase/6/docs/api/javax/security/auth/login/LoginContext.html">
      javax.security.auth.login.LoginContext</a> class (from the standard JAAS API) in order to authenticate users.
   In this case, we don't want our tests to actually execute any of the real JAAS code, since it may depend on external
   configuration and might not easily work in a developer testing environment.
   Besides, we also don't want to exercise real JAAS code in a unit test because obviously that is not part of the
   application code we <em>are</em> trying to test.
   (Of course, in <em>integration tests</em> we just might work with a real JAAS setup.)  
   Therefore, an application class depending on <code class="type">LoginContext</code> will be our "unit under test",
   while the <code class="type">LoginContext</code> class (the dependency) will have at least some of its methods and
   constructors "mocked" for any given test which involves authentication logic.
</p>

<h3 id="mocks">
   Mock methods and mock classes
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#setUp"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   In the context of the Mockups API, a <em>mock method</em> is any method in a <em>mock class</em> that gets annotated
   with <code class="annotation">@Mock</code>.
   For short, in this chapter we refer to annotated mock methods simply as "mocks"; in other contexts, the word "mock"
   may refer to an <em>instance</em> of a mocked class instead.
   A <em>mock class</em> is any class extending the <code class="type">mockit.MockUp&lt;T></code> generic base class,
   where <code>&lt;T></code> is the type to be mocked.
   The example below shows several mocks defined in a mock class for our example "real" class,
   <code class="type">javax.security.auth.login.LoginContext</code>.
</p>
<pre><code>public final class MockLoginContext extends MockUp&lt;LoginContext>
{
   @Mock
   public void $init(String name, CallbackHandler callbackHandler)
   {
      assertEquals("test", name);
      assertNotNull(callbackHandler);
   }

   @Mock
   public void login() {}

   @Mock
   public Subject getSubject() { return null; }
}
</code></pre>
<p>
   When a mock class is applied to a real class, the latter gets the implementation of those methods and constructors
   which have corresponding mocks temporarily replaced with the implementations of the matching mock methods, as
   defined in the mock class.
   In other words, the real class becomes "mocked" for the duration of the test which applied the mock class, and will
   respond accordingly whenever it receives invocations during test execution.
   At runtime, what really happens is that the execution of a mocked method/constructor is intercepted and redirected to
   the corresponding mock method, which then executes and returns (unless an exception/error is thrown) to the original
   caller, without this one noticing that a different method was actually executed.
   Normally, the "caller" class is the one under test, while the mocked class is a dependency.
</p>
<p>
   Mock classes are often defined as nested (<code>static</code>), inner (non-<code>static</code>), or even more often
   as <em>anonymous</em> classes inside a JUnit/TestNG test class.
   There is nothing preventing mock classes from being top-level, though.
   That would be useful if the mock class is to be reused in multiple test classes.
   As we'll see later, often the most convenient way to implement mock classes is by making them <em>anonymous</em>
   and <em>local</em> to an individual test method.
</p>
<p>
   A new mock class is created when we have a "real class" defined in production code which needs to be mocked for a
   given test.
   It should define at least one mock method, with any number of additional methods and constructors;
   it can also define any number of fields.
</p>
<p>
   Each <code class="annotation">@Mock</code> method must have a corresponding "real method/constructor" with the
   <em>same signature</em> in the targeted real class.
   For a mocked <em>method</em>, the signature consists of the method name and parameters; for a mocked
   <em>constructor</em>, it's just the parameters, with the mock method having the special name "<code>$init</code>".
   If a matching real method/constructor cannot be found for a given mock method, either in the specified real class or
   in its super-classes (excluding <code>java.lang.Object</code>), an <code class="type">IllegalArgumentException</code>
   is thrown when the test attempts to apply the mock class.
   Notice this exception can be caused by a refactoring in the real class (such as renaming the real method), so it's
   important to understand why it happens.
</p>
<p>
   Finally, notice there is no need to have mocks for <em>all</em> methods and constructors in a real class.
   Any such method or constructor for which no corresponding mock exists in the mock class will simply stay "as is",
   that is, it won't be mocked.
   This, of course, assuming there isn't some <em>other</em> mock class applied by the same test to the same real class,
   something which is perfectly valid (and sometimes useful).
   If two (or more) mock classes happen to be applied to the same real class for the same test, then such mock classes
   should avoid defining the same mock twice.
   In case a mock <em>is</em> duplicated, though, the "last" one to be applied wins.
</p>

<h3 id="setUp">
   Setting up mocks for a test
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#mocks"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#interfaces"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   A given mock class must be applied to a corresponding real class to have any effect.
   We call this "setting up" the mock class.
   This is usually done inside an individual test method or inside a <code class="annotation">@BeforeMethod</code>
   (TestNG) or <code class="annotation">@Before</code> (JUnit 4) method.
   Once a mock class is set up, all executions of the mocked methods and constructors of the real class get
   automatically redirected to the corresponding mock methods.
</p>
<p>
   To set up the <code class="type">MockLoginContext</code> mock class above, we simply instantiate it:
</p>
<pre><code>   @Test
   public void settingUpAMockClass() throws Exception
   {
      <strong>new MockLoginContext()</strong>);

      // Inside an application class which creates a suitable <span class="type">CallbackHandler</span>:
      new LoginContext("test", callbackHandler).login();

      ...
   }
</code></pre>
<p>
   Since the mock class is set up inside a test method, the mocking of <code class="type">LoginContext</code> by
   <code class="type">MockLoginContext</code> will be in effect only for that particular test.
</p>
<p>
   When the constructor invocation that instantiates <code class="type">LoginContext</code> executes, the corresponding
   "<code>$init</code>" mock method in <code class="type">MockLoginContext</code> will be executed, asserting the
   validity of the invocation arguments.
   Similarly, when the <code>LoginContext#login</code> method is called, the corresponding mock method will be executed,
   which in this case will do nothing since the method has no parameters and <code>void</code> return type.
   The mock class instance on which these invocations occur is the one created in the first part of the test.
</p>
<p>
   The (partial) example test above simply verifies that the <code class="type">LoginContext</code> class is
   instantiated with valid arguments through a particular constructor that takes a context name and a callback handler.
   If the real class is not instantiated at all, the test would still pass (unless some other condition causes it to
   fail).
   The invocation of the <code>login</code> method also has no effect on the outcome of this test, except for the fact
   that such an invocation will result in the execution of an empty mock method instead of the real method.
</p>
<p>
   Now, what if we wanted to simulate an authentication failure for a different test?
   The <code>LoginContext#login()</code> method declares that it can throw a <code class="type">LoginException</code>
   "if the authentication fails", so what we need to do is very simple (using JUnit 4 in this example):
</p>
<pre><code>   public static class MockLoginContextThatFailsAuthentication extends MockUp&lt;LoginContext>
   {
      @Mock
      public void $init(String name) {}

      @Mock
      public void login() throws LoginException
      {
         throw new LoginException();
      }
   }

   @Test(expected = LoginException.class)
   public void settingUpAnotherMockClass() throws Exception
   {
      new <strong>MockLoginContextThatFailsAuthentication</strong>();

      // Inside an application class:
      new LoginContext("test").login();
   }
</code></pre>
<p>
   This test will only pass if the <code>LoginContext#login</code> method throws an exception, which it will when the
   corresponding mock method is executed.
</p>

<h4 id="mockableMethods">Kinds of methods which can have mocks</h4>
<p>
   So far, we have only mocked public instance methods with public instance mock methods.
   In reality, any other kind of method in a real class can be mocked: methods with <code>private</code>,
   <code>protected</code> or "package-private" accessibility, <code>static</code> methods, <code>final</code> methods,
   and <code>native</code> methods.
   (Also <code>synchronized</code> and <code>strictfp</code> methods, but these modifiers only affect the method
   implementation, not its interface.)
   Even more, an <code>static</code> method in the real class can be mocked by an <em>instance</em> mock method, and
   vice-versa (an instance real method with an <code>static</code> mock); the same applies for the <code>final</code>
   modifier.
</p>
<p>
   Methods to be mocked need to have an implementation, though not necessarily in bytecode (in the case of
   <code>native</code> methods).
   Therefore, an <code>abstract</code> method cannot be mocked directly, and the same applies to the methods of a Java
   <code>interface</code>.
   (That said, as shown later the Mockups API can automatically create a proxy class that implements an interface.)
</p>

<h4 id="inline">In-line mock classes</h4>
<p>
   Typically, an specific group of mock methods for a given real class will only be useful for a single test.
   In such a situation we can create an <em>anonymous mock class</em> inside an individual test method, as demonstrated
   by the next example.
</p>
<pre><code>   @Test
   public void setingUpMocksUsingAnAnonymousMockClass() throws Exception
   {
      new MockUp&lt;LoginContext>() {
         @Mock void $init(String name) { assertEquals("test", name); }
         @Mock void login() {}
      });

      new LoginContext("test").login();
   }
</code></pre>
<p>
   Note that mock methods don't need to be <code>public</code>.
</p>

<h3 id="interfaces">
   Mocking interfaces
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#setUp"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#constraints"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Most of the time a mock class targets a real class directly.
   But what if we need a mock object that implements a certain interface, to be passed to code under test?
   The following example test shows how it is done for the interface
   <a href="http://download.oracle.com/javase/6/docs/api/javax/security/auth/callback/CallbackHandler.html">
      javax.security.auth.callback.CallbackHandler</a>.
</p>
<pre><code>   @Test
   public void mockingAnInterface() throws Exception
   {
      CallbackHandler callbackHandler = new MockUp&lt;CallbackHandler>() {
         @Mock
         void handle(Callback[] callbacks)
         {
            assertEquals(1, callbacks.length);
            assertTrue(callbacks[0] instanceof NameCallback);
         }
      }<strong>.getMockInstance()</strong>;

      callbackHandler.handle(new Callback[] {new NameCallback("Enter name:")});
   }
</code></pre>
<p>
   The <a href="../javadoc/mockit/MockUp.html#getInstance()"><code>MockUp#getMockInstance()</code></a> method returns a
   proxy object that implements the desired interface.
   This method returns <code>null</code> if the mocked type is not an interface.
</p>

<h3 id="constraints">
   Invocation count constraints
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#interfaces"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#initializers"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   All example tests shown so far only used JUnit/TestNG "asserts" to verify invocation arguments.
   This is the part of the API that extends conventional state-based testing to the data items
   exchanged between objects.
   Sometimes, though, we may want to verify if a given method/constructor in a dependency is invoked
   at all by the unit under test.
   We may also want to verify exactly how many invocations a given mock received during the
   execution of a test, or specify that the test should fail if more/less than a certain number of
   invocations occurs.
   For this, we can specify <em>declarative constraints</em> on the <em>invocation count</em> of a
   given mock, as the following example shows.
</p>
<pre><code>   @Test
   public void specifyingInvocationCountConstraints() throws Exception
   {
      new MockUp&lt;LoginContext>() {
         @Mock(<strong>minInvocations = 1</strong>)
         void $init(String name) { assertEquals("test", name); }

         @Mock(<strong>invocations = 1</strong>)
         void login() {}

         @Mock(<strong>maxInvocations = 1</strong>)
         void logout() {}
      });

      new LoginContext("test").login();
   }
</code></pre>
<p>
   In this test we used all three attributes of the <code class="annotation">@Mock</code> annotation related to
   invocation counts.
   The first mock specifies that the <code>LoginContext(String)</code> constructor must be invoked
   <em>at least once</em> during the test.
   The second one specifies that the <code>login()</code> method must be invoked <em>exactly once</em>, while the third
   declares that <code>logout()</code> <em>can</em> be invoked, but not more than once.
</p>
<p>
   It is also valid to specify both <code>minInvocations</code> and <code>maxInvocations</code> on
   the same mock, in order to constrain the invocation count to a given range.
</p>

<h3 id="initializers">
   Mocking class initializers
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#constraints"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#it"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   When a class in production code performs some work in one or more <em>static initialization blocks</em>, we often
   need to mock it out so it doesn't interfere with test execution.
   We can define an special mock method for that, as shown below.
</p>
<pre><code>   @Test
   public void mockingStaticInitializers()
   {
      new MockUp&lt;ClassWithStaticInitializers>() {
         @Mock
         <strong>void $clinit()</strong>
         {
            // Do something here, usually nothing.
         }
      };

      ClassWithStaticInitializers.doSomething();
   }
</code></pre>
<p>
   Special care must be taken when the static initialization code of a class is mocked out.
   Note that this includes not only any "<code>static</code>" blocks in the class, but also any assignments to
   <code>static</code> fields (excluding those resolved at compile time, which do not produce any executable bytecode).
   Since the JVM only attempts to initialize a class <em>once</em>, restoring the static initialization code of a
   mocked out class will not have any effect.
   So, if you mock out the static initialization of a class that hasn't been initialized by the JVM yet, the original
   class initialization code will <em>never</em> be executed in the test run.
   This will cause any static fields that are assigned with expressions computed at runtime to instead remain
   initialized with the <em>default</em> values for their types.
</p>

<h3 id="it">
   Accessing the mocked object: the "it" field
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#constraints"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#reentrant"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   As we have seen, there is a relationship between <em>mocked instances</em> (that is, instances of real classes which
   have been mocked) and <em>mock instances</em> (instances of mock classes).
   While <em>mock</em> instances get created explicitly in test code, <em>mocked</em> instances are created inside
   tested code, or in test code so they can be passed to tested code.
</p>
<p>
   For certain use cases, a mock method executing on a mock instance may need access to the corresponding mocked
   instance.
   This can be achieved by declaring an instance field of name "<strong><code>it</code></strong>" in the mock class,
   with the type of the mocked real class.
   Every time a mocked instance method is redirected to execute the corresponding mock instance method, the
   <code>it</code> field on the mock instance will be set to the mocked instance.
   If a mocked <em>constructor</em> has a corresponding <code>$init</code> mock method, then the field will be set to
   the newly created (and uninitialized) instance.
</p>
<p>
   In practice, the use of an <code>it</code> field by itself is uncommon, so the following example test is a contrived
   (although interesting) one.
   The next section describes a more likely use for such fields.
</p>
<pre><code>   @Test
   public void accessingTheMockedInstanceInMockMethods() throws Exception
   {
      final Subject testSubject = new Subject();

      new MockUp&lt;LoginContext>()
      {
         <strong>LoginContext it;</strong>

         @Mock(invocations = 1)
         void $init(String name, Subject subject)
         {
            assertNotNull(name);
            assertSame(testSubject, subject);

            // Forces setting of private Subject field, since no setter is available.
            setField(it, subject);
         }

         @Mock(invocations = 1)
         void login()
         {
            // getSubject() returns null until the subject is authenticated.
            assertNull(it.getSubject());

            // Private field set to true when login succeeds.
            setField(it, "loginSucceeded", true);
         }

         @Mock(invocations = 1)
         void logout()
         {
            assertSame(testSubject, it.getSubject());
         }
      };

      LoginContext theMockedInstance = new LoginContext("test", testSubject);
      theMockedInstance.login();
      theMockedInstance.logout();
   }
</code></pre>
<p>
   The <code>setField</code> methods used in this test are statically imported from the
   <code class="type">mockit.Deencapsulation</code> utility class, and are only used here to make the test more
   meaningful.
   The local variable <code>theMockedInstance</code> contains the instance which the <code>it</code> field will be set
   to on the mock-up instance, for each of the three mock invocations in this particular test.
</p>

<h3 id="reentrant">
   Reentrant mocks
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#it"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#reuse"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Usually, a <em>reentrant method</em> is one which can be re-entered once it is already executing.
   Recursive methods, for example, are typically reentrant.
   A <em>reentrant mock method</em> is similar, but instead of causing itself to be re-entered, it causes the
   corresponding <em>mocked</em> method to be re-entered; and when this happens the original code of the real method is
   executed, without going through the mock again.
</p>
<p>
   If the mock is an instance method mocking a real instance method, it will need access to the mocked instance in order
   to call back the mocked instance method.
   For this, the mock class will need to declare an appropriate <code>it</code> field.
</p>
<p>
   A mocked method which has a reentrant mock will have different behavior than if it had a regular mock, so we use the
   <code><span class="annotation">@Mock</span>(<strong>reentrant = true</strong>)</code> annotation attribute to tell
   JMockit about our intentions.
   The example test below exercises a <code class="type">LoginContext</code> object created normally (without any
   mocking in effect at creation time), using an unspecified <code>configuration</code>.
   (For the complete version of the test, see the
   <a href="http://code.google.com/p/jmockit/source/browse/trunk/main/test/mockit/MockAnnotationsTest.java">
      <code>mockit.MockAnnotationsTest</code></a> class.)
</p>
<pre><code>   @Test
   public void reenterMockedMethodsThroughItField() throws Exception
   {
      // Create objects to be exercised by the code under test:
      LoginContext loginContext = new LoginContext("test", null, null, configuration);

      // Set up mocks:
      ReentrantMockLoginContext mockInstance = new ReentrantMockLoginContext();

      // Exercise the code under test:
      assertNull(loginContext.getSubject());
      <strong>loginContext.login();</strong>
      assertNotNull(loginContext.getSubject());
      assertTrue(mockInstance.loggedIn);

      mockInstance.ignoreLogout = true;
      <strong>loginContext.logout();</strong> // first entry, won't re-enter
      assertTrue(mockInstance.loggedIn);

      mockInstance.ignoreLogout = false;
      <strong>loginContext.logout();</strong> // second entry, will re-enter
      assertFalse(mockInstance.loggedIn);
   }

   static final class ReentrantMockLoginContext extends MockUp&lt;LoginContext>
   {
      LoginContext <strong>it</strong>;
      boolean ignoreLogout;
      boolean loggedIn;

      @Mock(<strong>reentrant = true</strong>)
      void login() throws LoginException
      {
         try {
            <strong>it.login();</strong> // re-enters the mocked method, executing the real code
            loggedIn = true;
         }
         finally {
            // This is here just to show that arbitrary actions can be taken inside
            // the mock, <em>before</em> and/or <em>after</em> the real method gets executed.
            System.out.println("Login attempted for " + it.getSubject());
         }
      }

      @Mock(<strong>reentrant = true</strong>)
      void logout() throws LoginException
      {
         // A reentrant mock execution can re-enter the mocked method <em>or not</em>,
         // based on a condition.
         if (!ignoreLogout) {
            <strong>it.logout();</strong>
            loggedIn = false;
         }
      }
   }
</code></pre>
<p>
   In the example above, <em>all</em> real code exercised by the test actually gets executed, even though some methods
   (<code>login</code> and <code>logout</code>) are mocked.
   The example indeed is contrived; in practice, reentrant mocks would not normally be useful for <em>testing</em> per
   se, not directly at least.
</p>
<p>
   You may have noticed that a reentrant mock effectively behaves like <em>advice</em> (from AOP jargon) for the
   corresponding real method.
   This is a powerful ability that can be useful for certain things.
   JMockit itself uses mock classes containing reentrant mocks to provide integration with the JUnit and TestNG test
   runners.
</p>

<h3 id="reuse">
   Reusing mocks between tests
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#reentrant"><img align="right" src="go-up.png" title="Previous section"></a>
      <img align="right" src="blank.gif" width="22">
   </div>
</h3>
<p>
   Most tests will probably only use dedicated mock classes, specifically created for each particular test.
   There will be times, though, when the same mock class can be reused by multiple test methods,
   either in a single test class or across the entire test suite.
   We will now see different ways to set up mocks so they are shared by a whole group of tests, as
   well as ways to define reusable mock classes.
</p>

<h4 id="beforeAfter">Using before/after methods</h4>
<p>
   In a given test class, we can define instance methods that will run <em>before</em> and <em>after</em> each test
   method (even when the test throws an error or exception).
   With JUnit 3.8-style tests, these are the <code>setUp()</code> and <code>tearDown()</code> method overrides.
   In JUnit 4.x we use the <code class="annotation">@Before</code> and <code class="annotation">@After</code>
   annotations on one or more arbitrary instance methods of the test class. The same applies to the
   <code class="annotation">@BeforeMethod</code> and <code class="annotation">@AfterMethod</code> annotations of TestNG.
</p>
<p>
   Any mock class that can be applied from inside a test method can also be applied from a "before"
   method, using one of the "set-up" methods or by instantiating a mock-up class.
   Such a mock class will remain in effect for the execution of all test methods in the test class.
   The only difference of applying mocks in a "before" method is that they also remain in effect inside "after" methods,
   if any.
</p>
<p>
   For example, if we wanted to mock the <code class="type">LoginContext</code> class with a mock-up class for a bunch
   of related tests, we would have the following methods in the test class:
</p>
<pre><code>public class MyTestClass
{
   @Before
   public void setUpSharedMocks()
   {
      new MockUp&lt;LoginContext>()
      {
         // shared mocks here...
      };
   }

   // test methods that will share the mocks set up above...
}
</code></pre>
<p>
   If we had an annotated mock class instead of a mock-up, the set up would be done with a
   <code>Mockit.setUpMocks(NamedMockClass.class)</code> call or with a <code>Mockit.setUpMock</code> variant.
</p>
<p>
   The example above uses JUnit 4, but the equivalent code for TestNG or with JUnit 3.8-style tests would be almost the
   same.
</p>
<p>
   It is also valid to extend from base test classes, which may optionally define "before" and/or "after" methods
   containing calls to the Mockups API.
</p>

<h4 id="reusableMocks">Reusable mock classes</h4>
<p>
   Named mock classes of all kinds (annotated with <code class="annotation">@MockClass</code> or not, mock-up classes)
   can be designed as concrete (and optionally <code>final</code>) classes that are then used in specific tests.
   When instantiated directly by test code, such mock instances can be configured through constructor arguments, fields,
   or non-mock methods.
   Alternatively, they can be designed as base classes (possibly <code>abstract</code>) to be extended by concrete mock
   classes inside specific test classes or methods.
</p>
<p>
   The example tests for this section come from JMockit's own test suite. They exercise the following class, partially
   reproduced here:
</p>
<pre><code>public final class TextFile
{
   // fields and constructors that accept a TextReader or DefaultTextReader object...
   
   public List&lt;String[]> parse()
   {
      <strong>skipHeader();</strong>

      List&lt;String[]> result = new ArrayList&lt;String[]>();

      while(true) {
         String  strLine = <strong>nextLine();</strong>

         if (strLine == null) {
            <strong>closeReader();</strong>
            break;
         }

         String[] parsedLine = strLine.split(",");
         result.add(parsedLine);
      }

      return result;
   }

   // private helper methods that call "skip(n)", "readLine()", and "close()"...
   
   public interface <strong>TextReader</strong>
   {
      long skip(long n) throws IOException;
      String readLine() throws IOException;
      void close() throws IOException;
   }

   static final class <strong>DefaultTextReader</strong> implements TextReader
   {
      DefaultTextReader(String fileName) throws FileNotFoundException { ...mocked... }
      public long skip(long n) throws IOException { ...mocked... }
      public String readLine() throws IOException { ...mocked... }
      public void close() throws IOException { ...mocked... }
   }
}
</code></pre>
<p>
   Some of the tests for the class above are as follows.
</p>
<pre><code>public final class TextFileUsingMockUpsTest
{
   // A reusable mock-up class to be directly instantiated in specific tests.
   static final class <strong>MockTextReaderConstructor</strong> extends MockUp&lt;<strong>DefaultTextReader</strong>>
   {
      @Mock(invocations = 1)
      void $init(String fileName) { assertThat(fileName, equalTo("file")); }
   }

   @Test
   public void parseTextFileUsingDefaultTextReader() throws Exception
   {
      <strong>new MockTextReaderConstructor();</strong>
      <strong>new MockTextReaderForParse&lt;DefaultTextReader>() {};</strong>

      List&lt;String[]> result = new TextFile("file", 200).parse();

      // assert result from parsing
   }

   ...
</code></pre>
<p>
   The test above uses two reusable mock classes. The first one encapsulates a mock for the single constructor of the
   <code class="type">TextFile.DefaultTextReader</code> nested class.
   Any tests exercising code in the <code class="type">TextFile</code> class that invokes this constructor will
   therefore use this mock class.
   And since it is a mock-up class, it can be applied through simple instantiation inside the test method.
</p>
<p>
   The second mock class used by the test targets the same <code class="type">DefaultTextReader</code> class.
   As we see next, it defines mocks for a whole different set of members, which happen to be the methods called from
   the <code>TextFile#parse()</code> method.
</p>
<pre><code>   ...

   // A reusable base mock class to be extended in specific tests.
   static class <strong>MockTextReaderForParse&lt;T extends TextReader></strong> extends MockUp&lt;T>
   {
      static final String[] LINES = { "line1", "another,line", null};
      int invocation;

      @Mock(invocations = 1)
      long skip(long n)
      {
         assertEquals(200, n);
         return n;
      }

      @Mock(invocations = 3)
      String readLine() throws IOException { return LINES[invocation++]; }

      @Mock(invocations = 1)
      void close() {}
   }

   ...
</code></pre>
<p>
   The mock-up class above, like the <code class="type">mockit.MockUp&lt;T></code> class which it extends, is
   <em>generic</em>.
   In this particular case, this is necessary because the tested <code class="type">TextFile</code> class works
   with two different types for the "text reader" dependency:
   <code class="type">TextFile.TextReader</code> (an interface which client code can implement), and
   <code class="type">TextFile.DefaultTextReader</code> (an internal default implementation of the interface).
   The previous test simply used this mock class <em>as is</em>, by defining an anonymous subclass which specifies the
   type to be mocked as the <code class="type">DefaultTextReader</code> concrete class.
   The next test, on the other hand, passes a <code class="type">TextReader</code> implementation to
   <code class="type">TextFile</code>:
</p>
<pre><code>   ...

   @Test
   public void parseTextFileUsingProvidedTextReader() throws Exception
   {
      TextReader textReader = <strong>new MockTextReaderForParse&lt;TextReader>() {}</strong>.getMockInstance();

      List&lt;String[]> result = new TextFile(textReader, 200).parse();

      // assert result from parsing
   }

   ...
</code></pre>
<p>
   The interface implementation, in this case, is a mock proxy object obtained through the
   <code>MockUp&lt;T>#getMockInstance()</code> method.
</p>
<p>
   Finally, we get to a more interesting case, where the concrete mock subclass actually <em>overrides</em> some of the
   mocks inherited from the base mock class:
</p>
<pre><code>   ...

   @Test
   public void doesNotCloseTextReaderInCaseOfIOFailure() throws Exception
   {
      new MockTextReaderConstructor();
   
      <strong>new MockTextReaderForParse&lt;DefaultTextReader>()</strong>
      {
         <strong>@Override</strong> @Mock
         String readLine() throws IOException { <strong>throw new IOException();</strong> }

         <strong>@Override</strong> @Mock(<strong>invocations = 0</strong>)
         void close() {}
      };

      TextFile textFile = new TextFile("file", 200);

      try {
         textFile.parse();
         fail();
      }
      catch (RuntimeException e) {
         assertTrue(e.getCause() instanceof IOException);
      }
   }
}
</code></pre>
<p>
   The test forces an <code class="type">IOException</code> to be thrown in the first call to <code>readLine()</code>.
   (This exception will get wrapped in a <code class="type">RuntimeException</code> by the <code>parse</code> method.)
   It also specifies, through an invocation count constraint, that the <code>close()</code> method should never be
   called.
   This shows that not only the behavior of the inherited mock is overridden, but also any of the metadata specified
   through the <code class="annotation">@Mock</code> annotation.
</p>
<div class="navigation">
   <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
   <a href="ReflectionUtilities.html"><img align="right" src="go-next.png" title="Next chapter"></a>
   <a href="BehaviorBasedTesting.html"><img align="right" src="go-previous.png" title="Previous chapter"></a>
</div>
<br/>
</body>
</html>
